## 工厂模式：Factory Pattern

用工厂模式来替代new的主要原因是：

* 1、创建对象统一用工厂创建，方便修改

* 2、子类易于拓展

* 3、当构建一个对象需要附带一系列的动作、逻辑代码等，而这些大量代码尽量不放到构造函数中，把要做的事情解藕出来，因此在此处执行额外要做的事情

## 抽象工厂模式：Abstract Factory Pattern

抽象工厂模式，应用于模板一样的一系列产品的构建

        抽象工厂：品牌：Hp、Db
        产品：Hp鼠标、Hp键盘、Db鼠标、Db键盘

易于拓展：

* 当增加一个品牌QQ时，只需要增加一个QQ工厂实现类、QQ鼠标、QQ键盘

* 当增加一个产品耳机Head时，只需要增加Head接口及不同厂家的实现类DbHead、DbHead，及在抽象工厂中增加创建新产品的方法createHead

## 单例模式：Singleton Pattern

* 简单模式，加载类时就加载出实例，多线程安全，没有加锁

* 静态内部类模式：静态内部类会被延迟加载，只有通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance，同样多线程安全，没有加锁

* 双重锁模式：实例延迟加载，通过使用volatile修饰实例，保证多线程安全，在getInstance中使用synchronized的对象锁，保证创建实例时的同步锁

在使用单例模式创建实例时，推荐使用1，若明确需求要延迟加载再考虑2、3

## 建造者模式⭐️：Builder Pattern

建造者模式比较独立，将对象本身与构建过程解耦。使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，提供了创建对象的最佳方式。一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。

```java
public class NewMusic {
    private String writeWord;
    private String writeMusic;

    public NewMusic(Builder builder) {
        this.writeMusic = builder.writeMusic;
        this.writeWord = builder.writeWord;
    }

    protected static class Builder{
        private String writeWord;
        private String writeMusic;

        protected Builder composer(String composer){
            this.writeMusic = composer;
            return this;
        }

        protected Builder writer(String writer){
            this.writeWord = writer;
            return this;
        }

        protected NewMusic build(){
            return new NewMusic(this);
        }
    }
}
```

`NewMusic newMusic = new NewMusic.Builder().composer("chenshinan").writer("jaychou").build()`

## 原型模式：ProtoType Pattern

针对于构建过程复杂、繁琐的对象，又有频繁创建实例的场景，可以考虑使用原型模式克隆出新实例，根据需求选择浅拷贝【通过构造函数】与深拷贝【通过序列化】

### 浅拷贝实现：复制对象，对象属性是同一个引用

* 实现Cloneable接口，重写clone方法

* 通过传入对象的构造函数【推荐】

### 深拷贝实现：复制对象，包括对象属性也是全新对象

* 序列号，实现Serializable接口，添加deepCopy方法，用流复制对象【推荐】

* 通过传入对象的构造函数，若有对象属性需要new，子对象需要实现同样的构造函数

## 适配器模式：Adapter Pattern

        类适配器：通过继承来实现适配器功能
        对象适配器：通过组合来实现适配器功能
        接口适配器：通过抽象类来实现适配，只需用到接口中的部分方法

类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：

* 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。

* 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

> 以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。

接口适配器使用场景：

* 想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器

## 桥接模式：Bridge Pattern

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。`桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量`

> 桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意

例子中：可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的图形

## 过滤器模式：Filter Pattern

这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

过滤器模式只是一种设计思路，使得代码结构更清晰更好维护，就目前这些功能来说java8提供的stream处理起来更方便

## 组合模式：Composite Pattern

组合模式通过把叶子对象当成特殊的组合对象看待，从而对叶子对象和组合对象一视同仁，统统当成了Component对象，有机的统一了叶子对象和组合对象。

正是因为统一了叶子对象和组合对象，在将对象构建成树形结构的时候，才不需要做区分，反正是组件对象里面包含其它的组件对象，如此递归下去；也才使得对于树形结构的操作变得简单，不管对象类型，统一操作。

`适用于`：含有多层级关系的数据，访问时需要统一进行操作，例如：文件夹/文件、服装/商品

## 装饰器模式：Decorator Pattern

装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。当装饰过后，从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。这样就能够灵活的改变一个对象的功能，只要动态组合的装饰器发生了改变，那么最终所得到的对象的功能也就发生了改变。变相的还得到了另外一个好处，那就是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。

装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器里面调用被装饰对象的功能，获取相应的值，这其实是一种递归调用。装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并具有同一个外观，这样组合完成的装饰才能够递归的调用下去。

`装饰模式与适配器模式`（它们有一个共同的别名：Wrapper）：这两个模式功能上是不一样的，适配器模式是用来改变接口的，而装饰模式是用来改变对象功能的。一句话区别：`装饰模式是一个接口两个类，适配器模式是两个接口一个类`

## 外观模式：Facade Pattern

外观模式，封装内部复杂的方法调用，给客户端提供一个简单调用入口，松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护，对于一个子系统而言，外观类不需要很多，通常可以实现成为一个单例，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能的组合调用，外观模式很好的体现了“最少知识原则”

简单例子：电脑整机是 CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了

`适用于`：子系统调用复杂，通过外观类提供给客户端简单的调用接口（有点类似controller层）

## 享元模式：Flyweight Pattern

享元模式，真正应该被缓存的数据是那些不变且重复出现的数据，把它们称为对象的`内部状态`，而那些变化的数据就不缓存了，把它们称为对象的`外部状态`。在享元模式中，为了创建和管理共享的享元部分，引入了享元工厂，享元工厂中一般都包含有享元对象的实例池，享元对象就是缓存在这个实例池中的。内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态，但可以和内部状态封装成一个新的对象。在享元模式中，通常是在第一次向享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，不会从外部传入共享对象。

demo中加入了缓存的引用次数和垃圾回收

`适用于`：如果由于使用大量包含相同元素（内部状态）的对象，造成很大的存储开销，可以使用享元模式来减少对象实例数量，节约内存

## 代理模式⭐️：Proxy Pattern

代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象过后，对客户端没有什么影响，就跟得到了真实对象一样来使用。当客户端操作这个代理对象的时候，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，代理操作真正的对象

代理模式，由于一开始只查询部分属性，之后又要查看每一条详情而导致的1+N次查询，因此适用的场景是详情查的次数少的。Hibernate的Lazy Load就是使用代理来实现的，原理是一样的。

代理模式的本质：控制对象访问。代理模式通过代理目标对象，把代理对象插入到客户和目标对象之间，从而为客户和目标对象引入一定的间接性，正是这个间接性，给了代理对象很多的活动空间

通常把自己实现的代理模式，称为`Java的静态代理`,使用Java内建的对代理模式支持的功能来实现的代理称为`Java的动态代理`,Java的动态代理目前只能代理接口，基本的实现是依靠Java的反射机制和动态生成class的技术，来动态生成被代理的接口的实现对象。如果要实现类的代理，可以使用cglib。java反射就是在运行时动态获取类的信息，方法，构造方法等信息。可以加载一个在运行时才确定其名称信息的类，并确定该类的基本信息

`适用于`：

        需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理；
        需要按照需要创建开销很大的对象的时候，可以使用虚代理；
        需要控制对原始对象的访问的时候，可以使用保护代理；
        需要在访问对象的时候执行一些附加操作的时候，可以使用智能指引代理
        
## 责任链模式：Chain Of Responsebility Pattern

责任链模式，使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

首先职责链模式会定义一个所有处理请求的对象都要继承实现的抽象类，这样就有利于随时切换新的实现；其次每个处理请求对象只实现业务流程中的一步业务处理，这样使其变得简单；最后职责链模式会动态的来组合这些处理请求的对象

`标准链`是当找到合适的接收者处理后就停止了，`功能链`是一个请求在职责链中传递，每个职责对象负责处理请求的某一方面的功能，处理完成后，不是停止，而是继续向下传递请求，当请求通过很多职责对象处理过后，功能也就处理完了

`适用于`：

        如果有多个对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时刻动态确定的。这种情况可以使用职责链模式
        如果你想在不明确指定接收者的情况下，向多个对象中的一个提交一个请求的话，可以使用职责链模式
        如果想要动态指定处理一个请求的对象集合，可以使用职责链模式，职责链模式能动态的构建职责链eeee

`相似`：功能与装饰模式相似，但应用场景不同

## 命令模式：Command Pattern

> Client -> Invoker -> Command -> Receiver

命令模式的关键之处就是把请求封装成为对象，也就是命令对象，并定义了统一的执行操作的接口，这个命令对象可以被存储、转发、记录、处理、撤销等，整个命令模式都是围绕这个对象在进行。`例如参数化配置、可撤销操作、宏命令、队列请求、日志请求等功能处理`

在标准的命令模式里面，命令的实现类是没有真正实现命令要求的功能的，真正执行命令的功能的是接收者。如果命令的实现对象比较智能，它自己就能真实地实现命令要求的功能，而不再需要调用接收者，那么这种情况就称为智能命令

* `参数化配置`：可以用不同的命令对象，去参数化配置客户的请求

* `可撤销操作`：放弃该操作，回到未执行该操作前的状态`（两种思路：一种是补偿式，又称反操作式，另一种是存储恢复式）`

* `宏命令`：简单点说就是包含多个命令的命令，是一个命令的组合。`举个例子，就像是进饭店点菜，点了许多菜之后厨师才开始做菜`

* `队列请求`：就是对命令对象进行排队，组成工作队列，然后依次取出命令对象来执行

### 优点

* 降低耦合，调用者和接收者都不知道彼此

* 把请求封装，更方便控制

`适用于`：

        如果需要抽象出需要执行的动作，并参数化这些对象，可以选用命令模式，把这些需要执行的动作抽象成为命令，然后实现命令的参数化配置
        如果需要在不同的时刻指定、排列和执行请求，可以选用命令模式，把这些请求封装成为命令对象，然后实现把请求队列化
        如果需要支持取消操作，可以选用命令模式
        如果需要支持当系统崩溃时，能把对系统的操作功能重新执行一遍，可以选用命令模式
        在需要事务的系统中，可以选用命令模式
        
## 解释器模式：Interpreter Pattern

解析器：指的是把描述客户端调用要求的表达式，经过解析，形成一个抽象语法树的程序，不是指xml的解析器。

解释器：解析完成后，自动调用解释器来解释抽象语法树，并执行每个节点所对应的功能，从而完成通用的xml解析。`解释中的上下文context对象中有要解释的对象`

对于抽象的语法树这个树状结构，很明显可以使用组合模式来构建。解释器模式把需要解释的对象分成了两大类，一类是节点元素，就是可以包含其它元素的组合元素，比如非终结符元素，对应成为组合模式的Composite；另一类是终结符元素，相当于组合模式的叶子对象。解释整个抽象语法树的过程，也就是执行相应对象的功能的过程。

解释器模式使用解释器对象来表示和处理相应的语法规则，一般一个解释器处理一条语法规则

上下文在解释器模式中起到非常重要的作用，由于上下文会被传递到所有的解释器中，因此可以在上下文中存储和访问解释器的状态，比如前面的解释器可以存储一些数据在上下文中，后面的解释器就可以获取这些值。上下文还有一个功能，就是可以提供所有解释器对象的公共功能

解释器模式根据需求给定一个`表达式`（例如：root/a/b/c.name），将表达式解析成一个由解释器组成的`抽象语法树`，一个解释器对象处理一个语法规则的方式，把复杂的功能分离开；然后再按照抽象语法树传入`上下文`（上下文包含要解释的对象）来解释执行，实现相应的功能

`适用于`：

        当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式。
        在使用解释器模式的时候，还有两个特点需要考虑，一个是语法相对应该比较简单，太复杂的语法不合适使用解释器模式；另一个是效率要求不是很高，对效率要求很高的情况下，不适合使用解释器模式