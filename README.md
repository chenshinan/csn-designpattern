## 工厂模式：Factory Pattern

用工厂模式来替代new的主要原因是：

* 1、创建对象统一用工厂创建，方便修改

* 2、子类易于拓展

* 3、当构建一个对象需要附带一系列的动作、逻辑代码等，而这些大量代码尽量不放到构造函数中，把要做的事情解藕出来，因此在此处执行额外要做的事情

## 抽象工厂模式：Abstract Factory Pattern

抽象工厂模式，应用于模板一样的一系列产品的构建

        抽象工厂：品牌：Hp、Db
        产品：Hp鼠标、Hp键盘、Db鼠标、Db键盘

易于拓展：

* 当增加一个品牌QQ时，只需要增加一个QQ工厂实现类、QQ鼠标、QQ键盘

* 当增加一个产品耳机Head时，只需要增加Head接口及不同厂家的实现类DbHead、DbHead，及在抽象工厂中增加创建新产品的方法createHead

## 单例模式：Singleton Pattern

* 简单模式，加载类时就加载出实例，多线程安全，没有加锁

* 静态内部类模式：静态内部类会被延迟加载，只有通过显式调用getInstance方法时，才会显式装载SingletonHolder类，从而实例化instance，同样多线程安全，没有加锁

* 双重锁模式：实例延迟加载，通过使用volatile修饰实例，保证多线程安全，在getInstance中使用synchronized的对象锁，保证创建实例时的同步锁

在使用单例模式创建实例时，推荐使用1，若明确需求要延迟加载再考虑2、3

## 建造者模式⭐️：Builder Pattern

建造者模式比较独立，将对象本身与构建过程解耦。使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，提供了创建对象的最佳方式。一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。

```java
public class NewMusic {
    private String writeWord;
    private String writeMusic;

    public NewMusic(Builder builder) {
        this.writeMusic = builder.writeMusic;
        this.writeWord = builder.writeWord;
    }

    protected static class Builder{
        private String writeWord;
        private String writeMusic;

        protected Builder composer(String composer){
            this.writeMusic = composer;
            return this;
        }

        protected Builder writer(String writer){
            this.writeWord = writer;
            return this;
        }

        protected NewMusic build(){
            return new NewMusic(this);
        }
    }
}
```

`NewMusic newMusic = new NewMusic.Builder().composer("chenshinan").writer("jaychou").build()`

## 原型模式：ProtoType Pattern

针对于构建过程复杂、繁琐的对象，又有频繁创建实例的场景，可以考虑使用原型模式克隆出新实例，根据需求选择浅拷贝【通过构造函数】与深拷贝【通过序列化】

### 浅拷贝实现：复制对象，对象属性是同一个引用

* 实现Cloneable接口，重写clone方法

* 通过传入对象的构造函数【推荐】

### 深拷贝实现：复制对象，包括对象属性也是全新对象

* 序列号，实现Serializable接口，添加deepCopy方法，用流复制对象【推荐】

* 通过传入对象的构造函数，若有对象属性需要new，子对象需要实现同样的构造函数

## 适配器模式：Adapter Pattern

        类适配器：通过继承来实现适配器功能
        对象适配器：通过组合来实现适配器功能
        接口适配器：通过抽象类来实现适配，只需用到接口中的部分方法

类适配器与对象适配器的使用场景一致，仅仅是实现手段稍有区别，二者主要用于如下场景：

* 想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。

* 我们有一个类，想将其设计为可重用的类（可被多处访问），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。

> 以上两个场景其实就是从两个角度来描述一类问题，那就是要访问的方法不在合适的接口里，一个从接口出发（被访问），一个从访问出发（主动访问）。

接口适配器使用场景：

* 想要使用接口中的某个或某些方法，但是接口中有太多方法，我们要使用时必须实现接口并实现其中的所有方法，可以使用抽象类来实现接口，并不对方法进行实现（仅置空），然后我们再继承这个抽象类来通过重写想用的方法的方式来实现。这个抽象类就是适配器

## 桥接模式：Bridge Pattern

桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。`桥接模式将继承关系转化成关联关系，它降低了类与类之间的耦合度，减少了系统中类的数量，也减少了代码量`

> 桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意

例子中：可以使用相同的抽象类方法但是不同的桥接实现类，来画出不同颜色的图形

## 过滤器模式：Filter Pattern

这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。这种类型的设计模式属于结构型模式，它结合多个标准来获得单一标准。

过滤器模式只是一种设计思路，使得代码结构更清晰更好维护，就目前这些功能来说java8提供的stream处理起来更方便

## 组合模式：Composite Pattern

组合模式通过把叶子对象当成特殊的组合对象看待，从而对叶子对象和组合对象一视同仁，统统当成了Component对象，有机的统一了叶子对象和组合对象。

正是因为统一了叶子对象和组合对象，在将对象构建成树形结构的时候，才不需要做区分，反正是组件对象里面包含其它的组件对象，如此递归下去；也才使得对于树形结构的操作变得简单，不管对象类型，统一操作。

`适用于`：含有多层级关系的数据，访问时需要统一进行操作，例如：文件夹/文件、服装/商品

## 装饰器模式：Decorator Pattern

装饰模式能够实现动态的为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。当装饰过后，从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。这样就能够灵活的改变一个对象的功能，只要动态组合的装饰器发生了改变，那么最终所得到的对象的功能也就发生了改变。变相的还得到了另外一个好处，那就是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。

装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器里面调用被装饰对象的功能，获取相应的值，这其实是一种递归调用。装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并具有同一个外观，这样组合完成的装饰才能够递归的调用下去。

`装饰模式与适配器模式`（它们有一个共同的别名：Wrapper）：这两个模式功能上是不一样的，适配器模式是用来改变接口的，而装饰模式是用来改变对象功能的。一句话区别：`装饰模式是一个接口两个类，适配器模式是两个接口一个类`

## 外观模式：Facade Pattern

外观模式，封装内部复杂的方法调用，给客户端提供一个简单调用入口，松散了客户端与子系统的耦合关系，让子系统内部的模块能更容易扩展和维护，对于一个子系统而言，外观类不需要很多，通常可以实现成为一个单例，Facade的方法本身并不进行功能的处理，Facade的方法的实现只是实现一个功能的组合调用，外观模式很好的体现了“最少知识原则”

简单例子：电脑整机是 CPU、内存、硬盘的外观。有了外观以后，启动电脑和关闭电脑都简化了

`适用于`：子系统调用复杂，通过外观类提供给客户端简单的调用接口（有点类似controller层）

## 享元模式：Flyweight Pattern

享元模式，真正应该被缓存的数据是那些不变且重复出现的数据，把它们称为对象的`内部状态`，而那些变化的数据就不缓存了，把它们称为对象的`外部状态`。在享元模式中，为了创建和管理共享的享元部分，引入了享元工厂，享元工厂中一般都包含有享元对象的实例池，享元对象就是缓存在这个实例池中的。内部状态和外部状态是独立的，外部状态的变化不应该影响到内部状态，但可以和内部状态封装成一个新的对象。在享元模式中，通常是在第一次向享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，不会从外部传入共享对象。

demo中加入了缓存的引用次数和垃圾回收

`适用于`：如果由于使用大量包含相同元素（内部状态）的对象，造成很大的存储开销，可以使用享元模式来减少对象实例数量，节约内存

## 代理模式⭐️：Proxy Pattern

代理模式是通过创建一个代理对象，用这个代理对象去代表真实的对象，客户端得到这个代理对象过后，对客户端没有什么影响，就跟得到了真实对象一样来使用。当客户端操作这个代理对象的时候，实际上功能最终还是会由真实的对象来完成，只不过是通过代理操作的，也就是客户端操作代理，代理操作真正的对象

代理模式，由于一开始只查询部分属性，之后又要查看每一条详情而导致的1+N次查询，因此适用的场景是详情查的次数少的。Hibernate的Lazy Load就是使用代理来实现的，原理是一样的。

代理模式的本质：控制对象访问。代理模式通过代理目标对象，把代理对象插入到客户和目标对象之间，从而为客户和目标对象引入一定的间接性，正是这个间接性，给了代理对象很多的活动空间

通常把自己实现的代理模式，称为`Java的静态代理`,使用Java内建的对代理模式支持的功能来实现的代理称为`Java的动态代理`,Java的动态代理目前只能代理接口，基本的实现是依靠Java的反射机制和动态生成class的技术，来动态生成被代理的接口的实现对象。如果要实现类的代理，可以使用cglib。java反射就是在运行时动态获取类的信息，方法，构造方法等信息。可以加载一个在运行时才确定其名称信息的类，并确定该类的基本信息

`适用于`：

        需要为一个对象在不同的地址空间提供局部代表的时候，可以使用远程代理；
        需要按照需要创建开销很大的对象的时候，可以使用虚代理；
        需要控制对原始对象的访问的时候，可以使用保护代理；
        需要在访问对象的时候执行一些附加操作的时候，可以使用智能指引代理